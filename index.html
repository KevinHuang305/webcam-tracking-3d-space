<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Webcam VR Head Tracking + GLB Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: sans-serif;
        }

        /* 全螢幕 Canvas */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }

        /* 資訊與 Webcam 預覽區 */
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: white;
            width: 280px;
            pointer-events: none; /* 讓滑鼠穿透 */
        }

        .camera-preview {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid #555;
            margin-top: 10px;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* 控制面板 (右側) */
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            background: rgba(40, 40, 40, 0.9);
            color: white;
            padding: 20px;
            border-radius: 8px;
            z-index: 100;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: -5px 5px 15px rgba(0,0,0,0.5);
        }

        #controls h3 { margin-top: 0; border-bottom: 1px solid #666; padding-bottom: 10px; }
        .control-group { margin-bottom: 15px; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 0.9em; color: #aaa; }
        .control-group input[type="range"] { width: 100%; }
        .control-group input[type="file"] { width: 100%; font-size: 0.8em; }
        .value-display { float: right; color: #4CAF50; font-size: 0.8em; }

        /* 隱藏原生 Video 元素，我們用 CSS 顯示預覽 */
        #webcam-video {
            display: none;
        }
    </style>
</head>
<body>

    <div id="info-panel">
        <h2>VR 頭部追蹤視窗</h2>
        <p id="status">正在載入 AI 模型...</p>
        <video id="preview-video" class="camera-preview" autoplay playsinline muted></video>
        <div style="font-size: 0.8em; margin-top:5px; color:#aaa;">
            提示：請保持臉部在框線內，左右移動頭部觀察視差效果。
        </div>
    </div>

    <div id="controls">
        <h3>模型設定</h3>
        
        <div class="control-group">
            <label>載入 GLB 檔案</label>
            <input type="file" id="file-input" accept=".glb,.gltf">
        </div>

        <div class="control-group">
            <label>縮放 (Scale) <span id="val-scale" class="value-display">1.0</span></label>
            <input type="range" id="scale" min="0.1" max="5" step="0.1" value="1">
        </div>

        <hr style="border-color:#555">

        <div class="control-group">
            <label>位置 X <span id="val-posX" class="value-display">0</span></label>
            <input type="range" id="posX" min="-5" max="5" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>位置 Y <span id="val-posY" class="value-display">0</span></label>
            <input type="range" id="posY" min="-5" max="5" step="0.1" value="0">
        </div>
        <div class="control-group">
            <label>位置 Z <span id="val-posZ" class="value-display">0</span></label>
            <input type="range" id="posZ" min="-5" max="5" step="0.1" value="0">
        </div>

        <hr style="border-color:#555">

        <div class="control-group">
            <label>旋轉 X <span id="val-rotX" class="value-display">0</span></label>
            <input type="range" id="rotX" min="-3.14" max="3.14" step="0.01" value="0">
        </div>
        <div class="control-group">
            <label>旋轉 Y <span id="val-rotY" class="value-display">0</span></label>
            <input type="range" id="rotY" min="-3.14" max="3.14" step="0.01" value="0">
        </div>
        <div class="control-group">
            <label>旋轉 Z <span id="val-rotZ" class="value-display">0</span></label>
            <input type="range" id="rotZ" min="-3.14" max="3.14" step="0.01" value="0">
        </div>
    </div>

    <video id="webcam-video" autoplay playsinline></video>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';
        import { FilesetResolver, FaceLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        // --- 全域變數 ---
        let scene, camera, renderer, model;
        let faceLandmarker, lastVideoTime = -1;
        const video = document.getElementById('webcam-video');
        const previewVideo = document.getElementById('preview-video');
        const statusEl = document.getElementById('status');
        
        // --- 1. Three.js 初始化 ---
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            
            // 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            // 加入一些霧氣增加深度感
            scene.fog = new THREE.Fog(0x222222, 5, 15);

            // 攝影機 (FOV, Aspect, Near, Far)
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 3); // 初始位置

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 啟用陰影
            container.appendChild(renderer.domElement);

            // 燈光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(2, 5, 5);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 參考格線 (地板)
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
            scene.add(gridHelper);

            // 預設幾何體 (當還沒載入 GLB 時顯示)
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.3 });
            model = new THREE.Mesh(geometry, material);
            model.position.y = 0.5;
            model.castShadow = true;
            scene.add(model);

            // 視窗縮放處理
            window.addEventListener('resize', onWindowResize, false);
            
            // 啟動渲染迴圈
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // --- 2. MediaPipe 頭部追蹤邏輯 ---
        async function initMediaPipe() {
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numFaces: 1
                });
                
                statusEl.innerText = "模型載入完成，啟動相機...";
                startWebcam();
            } catch (error) {
                console.error(error);
                statusEl.innerText = "錯誤: " + error.message;
            }
        }

        function startWebcam() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                previewVideo.srcObject = stream; // 顯示在左上角預覽
                video.addEventListener("loadeddata", predictWebcam);
                statusEl.innerText = "追蹤中 (請嘗試移動頭部)";
            });
        }

        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (faceLandmarker) {
                    const result = faceLandmarker.detectForVideo(video, performance.now());
                    if (result.faceLandmarks.length > 0) {
                        const landmarks = result.faceLandmarks[0];
                        // 取眉心位置
                        const nose = landmarks[168]; 
                        updateCameraPerspective(nose.x, nose.y, nose.z);
                    }
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        // --- 3. 核心：將頭部位置映射到 Three.js 攝影機 ---
        function updateCameraPerspective(x, y, z) {
            // MediaPipe x, y 為 0~1。0.5 為中心。
            // 轉換為偏移量
            // 係數 (例如 5) 決定了攝影機移動的範圍幅度
            const rangeX = 8.0; 
            const rangeY = 4.0; 

            // 計算攝影機目標位置
            // 當頭向左 (x < 0.5)，攝影機也應該向左移動，但視線保持看中心，產生視差
            // 注意：Webcam 預設是鏡像的，這裡需要根據實際感受微調正負號
            const targetX = (x - 0.5) * -rangeX; 
            const targetY = (y - 0.5) * -rangeY + 1; // +1 是為了讓視角稍微高一點
            
            // 使用 lerp (線性插值) 讓移動更滑順，減少抖動
            camera.position.x += (targetX - camera.position.x) * 0.1;
            camera.position.y += (targetY - camera.position.y) * 0.1;
            
            // 讓攝影機永遠注視著場景中心 (或模型位置)
            camera.lookAt(0, 0.5, 0);
        }

        // --- 4. GLB 模型載入與 UI 控制 ---
        const loader = new GLTFLoader();

        // 綁定檔案上傳
        document.getElementById('file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const url = URL.createObjectURL(file);
            statusEl.innerText = "正在載入模型...";

            loader.load(url, (gltf) => {
                // 移除舊模型
                if (model) scene.remove(model);
                
                model = gltf.scene;
                scene.add(model);
                
                // 重置控制器數值
                updateModelTransform(); 
                statusEl.innerText = "模型載入成功！";
            }, undefined, (error) => {
                console.error(error);
                statusEl.innerText = "模型載入失敗";
            });
        });

        // 綁定滑桿事件
        const controlsIds = ['scale', 'posX', 'posY', 'posZ', 'rotX', 'rotY', 'rotZ'];
        controlsIds.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('input', updateModelTransform);
        });

        function updateModelTransform() {
            if (!model) return;

            const s = parseFloat(document.getElementById('scale').value);
            const px = parseFloat(document.getElementById('posX').value);
            const py = parseFloat(document.getElementById('posY').value);
            const pz = parseFloat(document.getElementById('posZ').value);
            const rx = parseFloat(document.getElementById('rotX').value);
            const ry = parseFloat(document.getElementById('rotY').value);
            const rz = parseFloat(document.getElementById('rotZ').value);

            // 更新數值顯示
            document.getElementById('val-scale').innerText = s;
            document.getElementById('val-posX').innerText = px;
            document.getElementById('val-posY').innerText = py;
            document.getElementById('val-posZ').innerText = pz;
            document.getElementById('val-rotX').innerText = rx;
            document.getElementById('val-rotY').innerText = ry;
            document.getElementById('val-rotZ').innerText = rz;

            // 套用至模型
            model.scale.set(s, s, s);
            model.position.set(px, py, pz);
            model.rotation.set(rx, ry, rz);
        }

        // 啟動所有程式
        initThreeJS();
        initMediaPipe();

    </script>
</body>
</html>